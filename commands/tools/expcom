\033[0;34m##################################################################################
\033[1;35m=== Registers (x86) ===\033[0m
\033[0;31m- REGISTERS (meaning) x86 -\033[0m
ESP -> STACK POINTER
EBP -> BREAK POINTER

\033[1;35m=== Compiling ===\033[0m
\033[0;31m- tcc -\033[0m
tcc -g -o <output_name> <program.c>

\033[0;31m- gcc -\033[0m
gcc -o <output_name> <program.c>

\033[0;31m- asm (linux) -\033[0m
nasm -f elf <program.asm>
ld -o <program> <program.o>

\033[1;35m=== generating/creating shellcode ===\033[0m
...

\033[1;35m=== gdb ===\033[0m
\033[0;31m- starting a program with gdb -\033[0m
gdb <program>

\033[0;31m- run the program -\033[0m
r
run
r < payload
run < payload

\033[0;31m- Useful utility commands -\033[0m
where -> \033[0;37mDisplay where on the stack you are.\033[0m

\033[0;31m- disassembling functions -\033[0m
disas <main>
disas <some_function_name>

\033[0;31m- setting a breakpoint (on specific address space +?) -\033[0m
break <*main+9> -> \033[0;37mBreak at a specific address space within a function.\033[0m
break <*func_name+0> -> \033[0;37mBreak at the start of a function.\033[0m

\033[0;31m- examine the registers -\033[0m
\033[1;31mSwitch between how the stack is displayed:\033[0m
x/10wx $esp \033[0;37m-> Display as 4 bytes each (Hex).\033[0m 
x/10bx $esp \033[0;37m-> Display as a single byte each (Hex).\033[0m
x/10cx $esp \033[0;37m-> Display as a single character each (Hex).\033[0m

\033[1;31mExamine 10 addresspaces as hexadecimal starting at the $esp register:\033[0m
x/10x $esp \033[0;37m-> Examines the content of where $ESP is pointing at.\033[0m

\033[1;31mExamine 2 addresspaces as hexadecimal starting at the $ebp register (return addresses?):\033[0m
x/2x $ebp \033[0;37m-> Examines the content of where $EBP is pointing at.\033[0m

\033[1;31mExamine 5 addresspaces as instruction values starting at <a specific address>:\033[0m
x/5i <address> \033[0;37m-> Examines the content of where the specific address is pointing at.\033[0m

\033[1;31mExamine addresspaces as clear string values starting at $esp:\033[0m
x/s $esp \033[0;37m-> Examines the content of where $esp is pointing at.\033[0m

\033[1;35m=== payloads [ex1] ===\033[0m
\033[0;31m- generating first chars of the payload -\033[0m
perl -e 'print "A"x<size>' > payload
python3 -c "print('A'*<size>)" > payload \033[0;37m-> This will include a '\\n'\033[0m
python3 -c "import sys; sys.stdout.write('A'*64)" > payload \033[0;37m-> This will not include a '\\n'\033[0m 

\033[0;31m- generating extra 4 chars -\033[0m
perl -e 'print "A"x4' >> payload
python3 -c "import sys; sys.stdout.write('B'*4)" >> payload \033[0;37m-> This will not include a '\\n'\033[0m 

\033[0;31m- appending address to payload to ... -\033[0m
\033[1;31mORIGINAL ADDRESS EXAMPLE:\033[0m 0x080482e1
\033[1;31m(x86) LITTLE ENDIAN ADDRESS EXAMPLE:\033[0m \\xe1\\x82\\x04\\x08

perl -e 'print "\\xe1\\x82\\x04\\x08"' >> payload \033[0;37m-> Append to payload

\033[1;35m=== payloads [ex2] ===\033[0m
\033[0;31m- taking the difference of (buffersize - shellcode) for NOPs -\033[0m
perl -e 'print "\\x90"x(<sizeofbuf> - <sizeofshellcode>)' > payload
python3 -c "import sys; sys.stdout.buffer.write(b'\\x90'*(<sizeofbuf> - <sizeofshellcode>)" > payload

\033[0;31m- add the shellcode to the payload -\033[0m
cat shellcode >> payload

\033[1;35m=== utility commands ===\033[0m
\033[0;31m- examining payload -\033[0m
xxd -g <1-x> <file_name>

\033[0;31m- examining shellcode -\033[0m
objdump -d <program>

\033[0;31m- run program with payload -\033[0m
(cat payload; cat - ) | ./<program_file>
sudo sh -c '(cat payload; cat - ) | ./<program_file>'

\033[0;34m##################################################################################
\n
